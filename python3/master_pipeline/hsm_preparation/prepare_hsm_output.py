"""
Author - Mayank Sharan
Date - 19/11/18
This function arranges the hsms generated by different appliances in format compliant to API writing format
"""

# Import python packages

import time
import logging
import numpy as np

# Import functions from within the project

from python3.config.mappings.get_app_id import get_app_id


def get_value_in_right_format(value):

    """Utility to modify value into correct format"""

    if type(value) == list:
        value = np.array(value)

    if type(value) == np.ndarray:

        if None in value:
            value[value == None] = 0
            value = value.astype(float)

        value[np.isnan(value)] = 0

        change_to_int = type(value[0]) == np.int64 or type(value[0]) == bool or type(value[0]) == np.bool_ or \
            type(value[-1]) == np.int64 or type(value[-1]) == bool or type(value[-1]) == np.bool_

        if change_to_int:
            value = value.astype(int)

        value = value.tolist()

    elif value is None or np.isnan(value):
        value = [0]
    elif type(value) == np.int64:
        value = [int(value)]
    else:
        value = [value]

    return value


def prepare_hsm_output(pipeline_output_object, logger_pass):

    """
    Parameters:
        pipeline_output_object(dict)              : Contains all outputs generated by running the pipeline
        logger_pass         (dict)              : Contains logging information needed to log here

    Returns:
        hsm_write_output    (list)              : List of all created HSMs in the required format
    """

    # Initialize logger

    logger_base = logger_pass.get('logger_base').getChild('prepare_hsm_output')
    logger = logging.LoggerAdapter(logger_base, logger_pass.get('logging_dict'))

    # Initialise variables required

    hsm_write_output = []
    created_hsm_dict = pipeline_output_object.get('created_hsm')

    # updating analytics hsm also
    analytics_hsm = pipeline_output_object.get('analytics_output_object',{}).get('created_hsm_analytics',{})
    if bool(analytics_hsm):
        created_hsm_dict['hvac']['attributes'].update(analytics_hsm.get('hvac_ineff',{}).get('attributes',{}))

    hsm_app_list = list(created_hsm_dict.keys())

    for app_name in hsm_app_list:

        created_hsm = created_hsm_dict.get(app_name)

        if created_hsm is None or not(type(created_hsm) == dict) or created_hsm.get('attributes') is None:
            continue

        attributes_list = list(created_hsm.get('attributes').keys())
        attribute_val_list = []

        # Initialize flag to identify if any of the attributes failed

        attributes_success = True

        for attribute in attributes_list:

            value = created_hsm.get('attributes').get(attribute)

            # Convert all numpy arrays to lists so that we can later on convert into JSON for posting

            # noinspection PyBroadException
            try:
                value = get_value_in_right_format(value)
            except Exception:
                logger.warning('HSM preparation failed | app: %s, attribute: %s', app_name, attribute)
                attributes_success = False
                break

            if len(value) == 0:
                continue

            attribute_val_list.append({
                "name": attribute,
                "value": value
            })

        # IF HSM preparation has failed move to the next appliance

        if not attributes_success:
            logger.warning('Skipping HSM for | %s', app_name)
            continue

        # Adding time of writing the current HSM as a key

        attribute_val_list.append({
            "name": 'hsm_creation_epoch',
            "value": [int(time.time())]
        })

        write_hsm = {
            "timestamp": created_hsm.get('timestamp'),
            "applianceType": get_app_id(app_name),
            "applianceNum": 0,
            "confidence": 1,
            "GbHSMAttributes": attribute_val_list,
            "appExists": True
        }

        hsm_write_output.append(write_hsm)

    return hsm_write_output
