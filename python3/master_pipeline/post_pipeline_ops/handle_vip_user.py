"""
Author - Mayank Sharan
Date - 17/1/19
If save results flag is true we save the results from current run to the csv and o/w if the uuid is vip we pick results
"""

# Import python packages

import os
import numpy as np
import pandas as pd

# Import functions from within the project

from python3.config.Cgbdisagg import Cgbdisagg
from python3.config.path_constants import PathConstants


def populate_out_matrix(bill_cycle_estimate, output_write_idx_map, out_matrix, out_idx_dict):

    """Utility to populate disagg values in the output matrix"""

    app_name_list = list(output_write_idx_map.keys())

    for app_name in app_name_list:

        if app_name == 'hvac':
            out_idx_list = output_write_idx_map.get(app_name)
            out_matrix[:, out_idx_dict['ac']] = bill_cycle_estimate[:, out_idx_list[0]].astype(str)
            out_matrix[:, out_idx_dict['sh']] = bill_cycle_estimate[:, out_idx_list[1]].astype(str)
        elif app_name == 'va':
            continue
        else:
            out_idx = output_write_idx_map.get(app_name)
            out_matrix[:, out_idx_dict[app_name]] = bill_cycle_estimate[:, out_idx].astype(str)

    out_matrix[:, out_idx_dict['bc_start']] = bill_cycle_estimate[:, 0].astype(str)
    return out_matrix


def populate_bill_cycle_estimate(bill_cycle_estimate, output_write_idx_map, user_disagg, out_idx_dict):

    """Utility to populate bill cycle estimate and replace it in disagg output object"""

    app_name_list = list(output_write_idx_map.keys())
    out_app_list = list(out_idx_dict.keys())

    res = np.intersect1d(bill_cycle_estimate[:, 0], user_disagg[:, out_idx_dict['bc_start']], return_indices=True)
    row_write_idx = res[1]

    for app_name in out_app_list:

        if app_name == 'ac' and 'hvac' in app_name_list:
            write_idx = output_write_idx_map['hvac'][0]

        elif app_name == 'sh' and 'hvac' in app_name_list:
            write_idx = output_write_idx_map['hvac'][1]

        elif app_name == 'ac' and 'hvac_smb' in app_name_list:
            write_idx = output_write_idx_map['hvac_smb'][0]

        elif app_name == 'sh' and 'hvac_smb' in app_name_list:
            write_idx = output_write_idx_map['hvac_smb'][1]

        elif app_name == 'ao' and 'ao_smb' in app_name_list:
            write_idx = output_write_idx_map['ao_smb']

        elif app_name in app_name_list:
            write_idx = output_write_idx_map[app_name]

        else:
            continue

        read_idx = out_idx_dict[app_name]
        bill_cycle_estimate[row_write_idx, write_idx] = user_disagg[:, read_idx]

    return bill_cycle_estimate


def handle_vip_user(disagg_input_object, disagg_output_object):

    """
    Parameters:
        disagg_input_object (dict)              : Contains all inputs required to run the pipeline
        disagg_output_object(dict)              : Contains all outputs generated by running the pipeline

    Returns:
        disagg_output_object(dict)              : Contains all outputs generated by running the pipeline
    """

    # Column idx mapping

    out_idx_dict = {
        'uuid': 0,
        'bc_start': 1,
        'ao': 2,
        'ac': 3,
        'sh': 4,
        'pp': 5,
        'so': 6,
        'li': 7,
        'wh': 8,
        'ref': 9,
        'ev': 10,
        'op':11,
        'x-ao':12
    }

    # VIP Users file location

    vip_users_dir = PathConstants.VIP_DIR
    vip_results_file = PathConstants.VIP_FILE

    config = disagg_input_object.get('config')
    uuid = config.get('uuid')

    if config.get('write_vip_user'):
        # Save the results from this run to the vip users csv

        if not(os.path.exists(vip_users_dir)):
            os.mkdir(vip_users_dir)

        if not(os.path.exists(vip_users_dir + vip_results_file)):
            f = open(vip_users_dir + vip_results_file, 'w')
            f.write('UUID, Bill cycle start, Always On, Refrigerator, Lighting, Cooling, Heating, Water Heater,'
                    'Pool Pump, Electric Vehicle, Solar\n')
            f.close()

        bill_cycle_estimate = np.round(disagg_output_object.get('bill_cycle_estimate'), decimals=2)
        output_write_idx_map = disagg_output_object.get('output_write_idx_map')

        out_matrix = np.full(shape=(bill_cycle_estimate.shape[0], len(out_idx_dict)), fill_value="0", dtype=object)

        # Populate the output matrix

        out_matrix[:, out_idx_dict['uuid']] = uuid
        out_matrix = populate_out_matrix(bill_cycle_estimate, output_write_idx_map, out_matrix, out_idx_dict)

        out_df = pd.DataFrame(data=out_matrix)
        out_df.to_csv(vip_users_dir + vip_results_file, mode='a', header=None, index=None)

        return disagg_output_object

    else:

        # Check if the user is a VIP and load the results from there to disagg output object

        if os.path.exists(vip_users_dir + vip_results_file):
            # Get the billing cycles

            bill_cycle_estimate = np.round(disagg_output_object.get('bill_cycle_estimate'), decimals=2)
            bill_cycles = bill_cycle_estimate[:, 0]
            output_write_idx_map = disagg_output_object.get('output_write_idx_map')

            # Extract the relevant rows from the data stored in the csv

            vip_df = pd.read_csv(vip_users_dir + vip_results_file, index_col=None)
            headers = vip_df.columns.values.tolist()

            user_df = vip_df.loc[vip_df[headers[out_idx_dict['uuid']]] == uuid]
            user_df = user_df.drop_duplicates(subset=headers[out_idx_dict['bc_start']], keep='last')
            user_df = user_df.loc[user_df[headers[out_idx_dict['bc_start']]].isin(bill_cycles)]

            if user_df.shape[0] > 0:
                bill_cycle_estimate = populate_bill_cycle_estimate(bill_cycle_estimate, output_write_idx_map,
                                                                   user_df.values, out_idx_dict)
                disagg_output_object['bill_cycle_estimate'] = bill_cycle_estimate

        return disagg_output_object
